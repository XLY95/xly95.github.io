<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="utf-8">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<title>ç”µå­ä»·ç­¾-æ–°42</title>
	<style>
/* åŸºç¡€æ ·å¼é‡ç½® */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  line-height: 1.6;
  color: #333;
  background-color: #f5f5f5;
  padding: 10px;
  max-width: 100%;
  overflow-x: hidden;
}

/* æŒ‰é’®æ ·å¼ä¼˜åŒ– */
button {
  background-color: #4a6ee0;
  color: white;
  border: none;
  padding: 12px 16px;
  margin: 5px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-height: 66px; /* è§¦æ‘¸å‹å¥½ */
  flex: 1 1 auto;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

button:hover {
  background-color: #3a5ecf;
  transform: translateY(-2px);
}

button:active {
  transform: translateY(0);
}

/* æŒ‰é’®ç»„å¸ƒå±€ */
.button-group {
  display: flex;
  flex-wrap: wrap;
  margin: 10px 0;
  gap: 8px;
}

.button-group button {
  flex: 1 1 calc(50% - 10px);
  min-width: 120px;
}

.button-group-vertical {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin: 10px 0;
}

/* è¡¨å•å…ƒç´ ä¼˜åŒ– */
input, select {
  width: 100%;
  padding: 12px;
  margin: 8px 0;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
  background-color: white;
  min-height: 44px; /* è§¦æ‘¸å‹å¥½ */
}

input[type="number"] {
  width: auto;
  min-width: 70px;
}

/* æ—¥æœŸé€‰æ‹©å™¨åŒºåŸŸ */
.date-picker-section {
  background-color: white;
  padding: 15px;
  border-radius: 10px;
  margin: 10px 0;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* ä¸»å†…å®¹åŒºåŸŸ */


.input-section, .preview-section {
  background-color: white;
  padding: 15px;
  border-radius: 10px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.section-title {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 15px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.input-group {
  margin-bottom: 15px;
}

.input-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 500;
}

.slider-container {
  display: flex;
  align-items: center;
  gap: 10px;
}

.slider-container input[type="range"] {
  flex: 1;
}

.slider-value {
  min-width: 50px;
  text-align: center;
}

/* ç”»å¸ƒåŒºåŸŸä¼˜åŒ– */
#canvas-box {
  position: relative;
  width: 100%;
  margin: 15px 0;
}

#canvas {
  width: 90%;
  max-width: 800px;
  height: auto;
  border: 2px solid #ddd;
  border-radius: 8px;
  background-color: white;
  touch-action: manipulation;
  display: block;
  margin: 0 auto; /* è¿™æ˜¯å…³é”® - æ°´å¹³å±…ä¸­ */
}

#tool-box {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 10px;
  padding: 10px;
  background-color: #f0f0f0;
  border-radius: 8px;
}

#tool-box select, #tool-box input, #tool-box button {
  flex: 1 1 auto;
  min-width: 100px;
  margin: 0;
}


    .log-box {
            margin-top: 15px;
        }
        
#log {
            height: 200px;
            overflow-y: auto;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
        }
        

/* é¢„è§ˆåŒºåŸŸ */
.preview-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

#previewCanvas {
  border: 1px solid #ddd;
  background-color: white;
  max-width: 100%;
  height: auto;
}

/* å“åº”å¼è®¾è®¡ */
@media (min-width: 768px) {
  .main-content {
    flex-direction: row;
  }
  
  .input-section {
    flex: 1;
  }
  
  .preview-section {
    flex: 1;
  }
  
  .button-group button {
    flex: 1 1 calc(33.333% - 10px);
  }
}

@media (max-width: 480px) {
  body {
    padding: 5px;
  }
  
  button {
    padding: 10px 12px;
    font-size: 14px;
  }
  
  .button-group button {
    flex: 1 1 100%;
  }
  
  #tool-box {
    flex-direction: column;
  }
  
  #tool-box select, #tool-box input, #tool-box button {
    width: 100%;
  }
}

/* ç‰¹æ®ŠæŒ‰é’®æ ·å¼ */
#generateBtn {
  
  background-color: #28a745;
}

#generateBtn:hover {
  background-color: #218838;
}

.copy-btn {
  background-color: #6c757d;
}

.copy-btn:hover {
  background-color: #5a6268;
}

/* é€‰é¡¹åŒºåŸŸ */
.options {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-top: 15px;
}

.option-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.option-item input[type="checkbox"] {
  width: auto;
  transform: scale(1.2);
}
</style>
	<script type="application/javascript" src="js/dithering.js"></script>
	<script type="application/javascript" src="js/utils.js"></script>
</head>

<body>
	<script>

    
	const bwrPalette = [
  [0, 0, 0, 255],
  [255, 255, 255, 255],
  [255, 0, 0, 255]
]

const bwPalette = [
  [0, 0, 0, 255],
  [255, 255, 255, 255],
]

function dithering(ctx, width, height, threshold, type) {
  const bayerThresholdMap = [
    [  15, 135,  45, 165 ],
    [ 195,  75, 225, 105 ],
    [  60, 180,  30, 150 ],
    [ 240, 120, 210,  90 ]
  ];

  const lumR = [];
  const lumG = [];
  const lumB = [];
  for (let i=0; i<256; i++) {
    lumR[i] = i*0.299;
    lumG[i] = i*0.587;
    lumB[i] = i*0.114;
  }
  const imageData = ctx.getImageData(0, 0, width, height);

  const imageDataLength = imageData.data.length;

  // Greyscale luminance (sets r pixels to luminance of rgb)
  for (let i = 0; i <= imageDataLength; i += 4) {
    imageData.data[i] = Math.floor(lumR[imageData.data[i]] + lumG[imageData.data[i+1]] + lumB[imageData.data[i+2]]);
  }

  const w = imageData.width;
  let newPixel, err;

  for (let currentPixel = 0; currentPixel <= imageDataLength; currentPixel+=4) {

    if (type ==="none") {
      // No dithering
      imageData.data[currentPixel] = imageData.data[currentPixel] < threshold ? 0 : 255;
    } else if (type ==="bayer") {
      // 4x4 Bayer ordered dithering algorithm
      var x = currentPixel/4 % w;
      var y = Math.floor(currentPixel/4 / w);
      var map = Math.floor( (imageData.data[currentPixel] + bayerThresholdMap[x%4][y%4]) / 2 );
      imageData.data[currentPixel] = (map < threshold) ? 0 : 255;
    } else if (type ==="floydsteinberg") {
      // Floydaâ‚¬"Steinberg dithering algorithm
      newPixel = imageData.data[currentPixel] < 129 ? 0 : 255;
      err = Math.floor((imageData.data[currentPixel] - newPixel) / 16);
      imageData.data[currentPixel] = newPixel;

      imageData.data[currentPixel       + 4 ] += err*7;
      imageData.data[currentPixel + 4*w - 4 ] += err*3;
      imageData.data[currentPixel + 4*w     ] += err*5;
      imageData.data[currentPixel + 4*w + 4 ] += err*1;
    } else {
      // Bill Atkinson's dithering algorithm
      newPixel = imageData.data[currentPixel] < threshold ? 0 : 255;
      err = Math.floor((imageData.data[currentPixel] - newPixel) / 8);
      imageData.data[currentPixel] = newPixel;

      imageData.data[currentPixel       + 4 ] += err;
      imageData.data[currentPixel       + 8 ] += err;
      imageData.data[currentPixel + 4*w - 4 ] += err;
      imageData.data[currentPixel + 4*w     ] += err;
      imageData.data[currentPixel + 4*w + 4 ] += err;
      imageData.data[currentPixel + 8*w     ] += err;
    }

    // Set g and b pixels equal to r
    imageData.data[currentPixel + 1] = imageData.data[currentPixel + 2] = imageData.data[currentPixel];
  }

  ctx.putImageData(imageData, 0, 0);
}

function canvas2bytes(canvas, type='bw') {
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  const arr = [];
  let buffer = [];
for (let y = 0; y < canvas.height; y++) {
  for (let x =0;x<canvas.width ; x++) {
    
      const index = (canvas.width * 4 * y) + x * 4;
      if (type !== 'bwr') {
        buffer.push(imageData.data[index] > 0 && imageData.data[index+1] > 0 && imageData.data[index+2] > 0 ? 1 : 0);
      } else {
        buffer.push(imageData.data[index] > 0 && imageData.data[index+1] === 0 && imageData.data[index+2] === 0 ? 1 : 0);
      }

      if (buffer.length === 8) {
        arr.push(parseInt(buffer.join(''), 2));
        buffer = [];
      }
    }
  }
  return arr;
}

function getColorDistance(rgba1, rgba2) {
  const [r1, b1, g1] = rgba1;
  const [r2, b2, g2] = rgba2;

  const rm = (r1 + r2 ) / 2;

  const r = r1 - r2;
  const g = g1 - g2;
  const b = b1 - b2;

  return Math.sqrt((2 + rm / 256) * r * r + 4 * g * g + (2 + (255 - rm) / 256) * b * b);
}

function getNearColor(pixel, palette) {
  let minDistance = 255 * 255 * 3 + 1;
  let paletteIndex = 0;

  for (let i = 0; i < palette.length; i++) {
    const targetColor = palette[i];
    const distance = getColorDistance(pixel, targetColor);
    if (distance < minDistance) {
      minDistance = distance;
      paletteIndex = i;
    }
  }

  return palette[paletteIndex];
}


function getNearColorV2(color, palette) {
  let minDistanceSquared = 255*255 + 255*255 + 255*255 + 1;

  let bestIndex = 0;
  for (let i = 0; i < palette.length; i++) {
      let rdiff = (color[0] & 0xff) - (palette[i][0] & 0xff);
      let gdiff = (color[1] & 0xff) - (palette[i][1] & 0xff);
      let bdiff = (color[2] & 0xff) - (palette[i][2] & 0xff);
      let distanceSquared = rdiff*rdiff + gdiff*gdiff + bdiff*bdiff;
      if (distanceSquared < minDistanceSquared) {
          minDistanceSquared = distanceSquared;
          bestIndex = i;
      }
  }
  return palette[bestIndex];

}


function updatePixel(imageData, index, color) {
  imageData[index] = color[0];
  imageData[index+1] = color[1];
  imageData[index+2] = color[2];
  imageData[index+3] = color[3];
}

function getColorErr(color1, color2, rate) {
  const res = [];
  for (let i = 0; i < 3; i++) {
    res.push(Math.floor((color1[i] - color2[i]) / rate));
  }
  return res;
}

function updatePixelErr(imageData, index, err, rate) {
  imageData[index] += err[0] * rate;
  imageData[index+1] += err[1] * rate;
  imageData[index+2] += err[2] * rate;
}

function ditheringCanvasByPalette(canvas, palette, type) {
  palette = palette || bwrPalette;

  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const w = imageData.width;

  for (let currentPixel = 0; currentPixel <= imageData.data.length; currentPixel+=4) {
    const newColor = getNearColorV2(imageData.data.slice(currentPixel, currentPixel+4), palette);

    if (type === "bwr_floydsteinberg") {
      const err = getColorErr(imageData.data.slice(currentPixel, currentPixel+4), newColor, 16);

      updatePixel(imageData.data, currentPixel, newColor);
      updatePixelErr(imageData.data, currentPixel +4, err, 7);
      updatePixelErr(imageData.data, currentPixel + 4*w - 4, err, 3);
      updatePixelErr(imageData.data, currentPixel + 4*w, err, 5);
      updatePixelErr(imageData.data, currentPixel + 4*w + 4, err, 1);
    } else {
      const err = getColorErr(imageData.data.slice(currentPixel, currentPixel+4), newColor, 8);

      updatePixel(imageData.data, currentPixel, newColor);
      updatePixelErr(imageData.data, currentPixel +4, err, 1);
      updatePixelErr(imageData.data, currentPixel +8, err, 1);
      updatePixelErr(imageData.data, currentPixel +4 * w - 4, err, 1);
      updatePixelErr(imageData.data, currentPixel +4 * w, err, 1);
      updatePixelErr(imageData.data, currentPixel +4 * w + 4, err, 1);
      updatePixelErr(imageData.data, currentPixel +8 * w, err, 1);
    }
  }
  ctx.putImageData(imageData, 0, 0);
}</script>

<script>
function hexToBytes(hex) {
  for (var bytes = [], c = 0; c < hex.length; c += 2)
    bytes.push(parseInt(hex.substr(c, 2), 16));
  return new Uint8Array(bytes);
}

function bytesToHex(data) {
  return new Uint8Array(data).reduce(
    function (memo, i) {
      return memo + ("0" + i.toString(16)).slice(-2);
    }, "");
}

function intToHex(intIn, bytes=4) {
    return intIn.toString(16).padStart(bytes * 2, '0');
}

</script>
	<script>
		let bleDevice;
		let gattServer;
		let epdService;
		let rxtxService;
		let epdCharacteristic;
		let rxtxCharacteristic;
		let reconnectTrys = 0;
		const my_step = 900;

		function delay(delayInMs) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(2);
    }, delayInMs);
  });
}

		function resetVariables() {
			gattServer = null;
			epdService = null;
			epdCharacteristic = null;
			rxtxCharacteristic = null;
			rxtxService = null;
			document.getElementById("log").value = '';
		}

		async function handleError(error) {
			console.log(error);
			resetVariables();
			if (bleDevice == null)
				return;
			if (reconnectTrys <= 5) {
				reconnectTrys++;
				await connect();
			}
			else {
				addLog("Was not able to connect, aborting");
				reconnectTrys = 0;
			}
		}
	
		async function sendCommand(cmd) {
			if (epdCharacteristic) {
				await epdCharacteristic.writeValueWithResponse(cmd)
			} else {
				addLog('æœåŠ¡ä¸å¯ç”¨ã€‚è“ç‰™é“¾æ¥ä¸Šäº†å—ï¼Ÿ')
			}
		}

		async function clearScreen(cmd) {
			addLog('åˆ·å±')
			await triggerEpdCmd(`00${cmd}`);
			await triggerEpdCmd('01')
		}

		async function rxTxSendCommand(cmd) {
		  if (rxtxCharacteristic) {
			await rxtxCharacteristic.writeValueWithResponse(cmd);
		  } else {
			  addLog('æœåŠ¡ä¸å¯ç”¨ã€‚è“ç‰™é“¾æ¥ä¸Šäº†å—ï¼Ÿ')
		  }
		}

		async function SendCommand(cmd) {
			let code;
			for(let i;i<cmd.length;i+=2){
				code=''+cmd[i]+cmd[i+1];
				triggerRxTxCmd(code);
				await delay(1000);
			}
		 	
		}

		async function rxTxSendCommand2(cmd) {
		  if (rxtxCharacteristic) {
			await rxtxCharacteristic.writeValueWith(cmd);
		  } else {
			  addLog('æœåŠ¡ä¸å¯ç”¨ã€‚è“ç‰™é“¾æ¥ä¸Šäº†å—ï¼Ÿ')
		  }
		}
		
		async function sendBufferData(value, type) {
			addLog(`å¼€å§‹å‘é€å›¾ç‰‡æ¨¡å¼:${type}, å¤§å° ${value.length}byte`);
			let code = 'ff';
			if (type === 'bwr') {
				code = '00';
			}

      let cod = '03';
      if (value.length==7000) { cod = '04';}
			const step = my_step;
			let partIndex = 0;
			for (let i = 0; i < value.length; i += step) {
				addLog(`æ­£åœ¨å‘é€ç¬¬${partIndex+1}å—. å—å¤§å°: ${step/2+4}byte. èµ·å§‹ä½ç½®: ${i/2}`);
				await sendCommand(hexToBytes(cod + code + intToHex(i / 2, 2) + value.substring(i, i + step)));
				partIndex += 1;
			}
		}
	function updateCanvasSize() {
			const sizeSelect = document.getElementById('screen-size');
			const canvas = document.getElementById('canvas');
			const ctx = canvas.getContext("2d");
		
			let width, height;


    
    // <option value="7.5ä¼ å›¾">2.9ä¼ å›¾</option> -->
    // <option value="2.9ä¼ å›¾">2.9ä¼ å›¾</option> -->
    //   <option value="2.13ä¼ å›¾">2.9ä¼ å›¾</
			if (sizeSelect.value == "4.2ä¼ å›¾") {
				width = 400;
				height = 300;
			}
       else if (sizeSelect.value === "2.9ä¼ å›¾"){
				width = 296;
				height = 128;
			}
       else if (sizeSelect.value === "æ—¥å†å°å›¾"){

        width	=  280;
				height =100;
      }
       else if (sizeSelect.value === "7.5ä¼ å›¾"){

        width	=  800;
				height =480;
      }
       else if (sizeSelect.value === "2.13ä¼ å›¾"){

        width	=  212;
				height =104;
      }
			
			canvas.width = width;
			canvas.height = height ;
			
			// æ¸…ç©ºå¹¶é‡ç½®èƒŒæ™¯ä¸ºç™½è‰²
			ctx.fillStyle = 'white';
			ctx.fillRect(0, 0, width, height);
			update_image () ;
			addLog(`ç”»å¸ƒå°ºå¯¸å·²æ›´æ–°ä¸º: ${width}x${height}`);
		}
		async function upload_image() {
			const canvas = document.getElementById('canvas');


			const startTime = new Date().getTime();


			// await sendCommand(hexToBytes("0000"));

			// await sendCommand(hexToBytes("020000"));

			await sendBufferData(bytesToHex(canvas2bytes(canvas)), 'bw')
			await sendBufferData(bytesToHex(canvas2bytes(canvas, 'bwr')), 'bwr')

       if (canvas.width ==280) { await sendCommand(hexToBytes("AA"))}
          else  { await sendCommand(hexToBytes("01"))}
			

			addLog(`ä¸Šä¼ å®Œæˆï¼Œè€—æ—¶${(new Date().getTime() - startTime)/1000}s`);
		}



		async function setTime() {
			const { unixNow, localeTimeString, year, month, day, week } = getUnixTime();

		  	addLog("æ—¶é—´è®¾ç½®ä¸º: " + localeTimeString + " : dd" + intToHex(unixNow, 4));
		  	await rxTxSendCommand(hexToBytes('dd' +
					[intToHex(unixNow, 4), intToHex(year, 2), intToHex(month, 1), intToHex(day, 1), intToHex(week, 1)].join('')));

			await rxTxSendCommand(hexToBytes('e2'))
		}

    async function setri(cmd) {
			await rxTxSendCommand(hexToBytes(cmd));
      await delay(300);
			await rxTxSendCommand(hexToBytes('e2'))
		}

		async function triggerRxTxCmd(cmd) {
			addLog(`å‘é€æŒ‡ä»¤: ${cmd}`)
			await rxTxSendCommand(hexToBytes(cmd));
		}
		async function triggerRxTxCmd2(cmd) {
			addLog(`å‘é€æŒ‡ä»¤: ${cmd}`)
			await rxTxSendCommand2(hexToBytes(cmd));
		}
		async function triggerEpdCmd(cmd) {
			addLog(`å‘é€æŒ‡ä»¤: ${cmd}`)
			await sendCommand(hexToBytes(cmd));
		}
	async function triggerEpdRed_lut(cmd) {
			addLog(`å¼€å§‹çº¢è‰²æ ¡å‡†: ${cmd}`)
      cmd='E6'+cmd;
			await rxTxSendCommand(hexToBytes(cmd));
      
		}
    async function triggerEpdJH(cmd) {
			addLog(`æ¿€æ´»æŒ‡ä»¤: ${cmd}`)
      cmd='EF'+cmd;
			await rxTxSendCommand(hexToBytes(cmd));
      await delay(300);
			await rxTxSendCommand(hexToBytes('e2'))
		}

		function disconnect() {
			resetVariables();
			addLog('é“¾æ¥å·²æ–­å¼€.');
			document.getElementById("connectbutton").innerHTML = 'é“¾æ¥';
		}

		async function preConnect() {
			if (gattServer != null && gattServer.connected) {
				if (bleDevice != null && bleDevice.gatt.connected)
					bleDevice.gatt.disconnect();
			}
			else {
				reconnectTrys = 0;
				bleDevice = await navigator.bluetooth.requestDevice({ filters: [
                { namePrefix: 'NRF-' }
            ],optionalServices: ['0000221f-0000-1000-8000-00805f9b34fb', '00001f10-0000-1000-8000-00805f9b34fb', '13187b10-eba9-a3ba-044e-83d3217d9a38'] });
				await bleDevice.addEventListener('gattserverdisconnected', disconnect);
				try {
					await connect();
				} catch (e) {
					await handleError(e);
				}
			}
		}

		async function connectRXTX() {
			rxtxService = await gattServer.getPrimaryService('00001f10-0000-1000-8000-00805f9b34fb');
			addLog('> rxtxService æ‰¾åˆ°ä¸²å£æœåŠ¡');

			rxtxCharacteristic = await rxtxService.getCharacteristic('00001f1f-0000-1000-8000-00805f9b34fb');
			addLog('> rxtxCharacteristic ä¸²å£æœåŠ¡å·²é“¾æ¥');
		}

		async function reConnect() {
			connectTrys = 0;
			if (bleDevice != null && bleDevice.gatt.connected)
				bleDevice.gatt.disconnect();
			resetVariables();
			addLog("é‡æ–°é“¾æ¥");
			setTimeout(async function () { await connect(); }, 300);
		}

		async function connect() {
			if (epdCharacteristic == null) {
				addLog("æ­£åœ¨é“¾æ¥: " + bleDevice.name);

				gattServer = await bleDevice.gatt.connect();
				addLog('> æ‰¾åˆ°GATTæœåŠ¡å™¨');

				epdService = await gattServer.getPrimaryService('13187b10-eba9-a3ba-044e-83d3217d9a38');
				addLog('>  epdService æ‰¾åˆ°å¯ç”¨æœåŠ¡');

				epdCharacteristic = await epdService.getCharacteristic('4b646063-6264-f3a7-8941-e65356ea82fe');
				addLog('> epdCharacteristic æœåŠ¡å·²è¿æ¥');

				await epdCharacteristic.startNotifications();

				epdCharacteristic.addEventListener('characteristicvaluechanged', (event) => {
					console.log('epd ret', bytesToHex(event.target.value.buffer))
					const count = parseInt('0x'+ bytesToHex(event.target.value.buffer));
					
					addLog(`> [æ¥è‡ªå±å¹•]: æ”¶åˆ°${count} byteæ•°æ®`);
					
					
				});

				document.getElementById("connectbutton").innerHTML = 'æ–­å¼€';
				await connectRXTX();
			}
		}

		function setStatus(statusText) {
			document.getElementById("status").innerHTML = statusText;
		}

		function addLog(logTXT) {
			const today = new Date();
			const time = ("0" + today.getHours()).slice(-2) + ":" + ("0" + today.getMinutes()).slice(-2) + ":" + ("0" + today.getSeconds()).slice(-2) + " : ";

			const dom = document.getElementById("log");

			dom.innerHTML += time + logTXT + '<br>';
			dom.scrollTop = dom.scrollHeight;
		}

		function getUnixTime() {
			const hourOffset = document.getElementById('hour-offset').value;
		  	const unixNow = Math.round(Date.now() / 1000)+(60*60*hourOffset)  - new Date().getTimezoneOffset() * 60;

			const date = new Date((unixNow + new Date().getTimezoneOffset() * 60)*1000);
		  	const localeTimeString = date.toLocaleTimeString();

			return {unixNow, localeTimeString, year: date.getFullYear(), month: date.getMonth() + 1, day: date.getDate(), week: date.getDay() || 7}
		}

		async function update_image () {
			const image_file = document.getElementById('image_file');
			if (image_file.files.length > 0) {
				const file = image_file.files[0];

				const canvas = document.getElementById("canvas");
				const ctx = canvas.getContext("2d");

				const image = new Image();
				image.src = URL.createObjectURL(file);
				image.onload = function(event) {
					URL.revokeObjectURL(this.src);
					ctx.drawImage(image, 0, 0,  image.width,image.height, 0, 0, canvas.width, canvas.height);
					convert_dithering()
				}
			}
		}

		function get_position(canvas, x, y){
			let rect = canvas.getBoundingClientRect()
			return {
				x: x - rect.left * (canvas.width/rect.width),
				y: y - rect.top * (canvas.height/rect.height)
			}
		}

		function clear_canvas() {
			if(confirm('ç¡®è®¤æ¸…é™¤å±å¹•?')) {
				const canvas = document.getElementById('canvas');
				const ctx = canvas.getContext("2d");
				ctx.fillStyle = 'white';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
			}
		}

		function convert_dithering() {
			const canvas = document.getElementById('canvas');
			const ctx = canvas.getContext("2d");
			const mode = document.getElementById('dithering').value;
			if (mode.startsWith('bwr')) {
				ditheringCanvasByPalette(canvas, bwrPalette, mode);
			} else {
				dithering(ctx, canvas.width, canvas.height, parseInt(document.getElementById('threshold').value), mode);
			}
		}

		document.body.onload = () => {
			setInterval(() => {
				const { localeTimeString, year, month, day, week } = getUnixTime();
				document.getElementById('time-setter').innerText = `è®¾ç½®æ—¶é—´ä¸ºï¼š${year}-${month}-${day} ${localeTimeString} æ˜ŸæœŸ${week}`;
			}, 1000);

			const canvas = document.getElementById('canvas');
			const ctx = canvas.getContext("2d");
      // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸ä¸º300x400
			updateCanvasSize();
			ctx.fillStyle = 'white';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			let is_allow_drawing = false;
			let is_allow_move_editor = false;
			const image_mode = document.getElementById('canvas-mode');
			const paint_size = document.getElementById('paint-size');
			const paint_color = document.getElementById('paint-color');
			const editor = document.getElementById('edit-font');
			const font = document.getElementById('font');
			document.getElementById('dithering').value = 'bwr_Atkinson';
			image_mode.value = 'paint';
			paint_color.value = 'black';
			font.value = 'é»‘ä½“';

			editor.onmousemove = function (e) {
				editor.style.fontSize = `${paint_size.value * 10}px`;
				editor.style.color = paint_color.value;
				editor.style.fontFamily = font.value;
				editor.style.fontWeight = 'bold';

				if (is_allow_move_editor) {
					const {x, y} = get_position(canvas, e.clientX, e.clientY);
					if (x < 0 || y < 0 || x > canvas.width || y > canvas.height) {
						return;
					}

					editor.style.left = `${e.clientX-20}px`;
					editor.style.top = `${e.clientY-20}px`;

				}
			}

			editor.onmousedown = function (e) {
				is_allow_move_editor = true;
			}

			editor.onmouseup = function (e) {
				is_allow_move_editor = false;
			}

			document.getElementById('update-text').onclick = function () {
				if (!editor.value.length) {
					alert('è¯·å…ˆè¾“å…¥æ–‡å­—');
					return;
				}
				editor.style.display = 'none';
				ctx.beginPath();
				ctx.font = `bold ${paint_size.value * 10}px ${font.value}`;
				ctx.fillStyle = paint_color.value;
				const {x, y} = get_position(canvas, parseInt(editor.style.left), parseInt(editor.style.top) + paint_size.value * 10);

				ctx.fillText(editor.value, x, y);
			}

			image_mode.onchange = function (e) {
				if (image_mode.value === 'font') {
					document.getElementById('update-text').style.display = 'inline-block';
					document.getElementById('font').style.display = 'inline-block';

					editor.style.display='block';
					editor.style.left = `${e.clientX}px`;
					editor.style.top = `${e.clientY}px`;
					return;
				}
				document.getElementById('update-text').style.display = 'none';
				document.getElementById('font').style.display = 'none';
				editor.style.display='none';
			}

			paint_size.onchange = function () {
				if (image_mode.value === 'font') {
					editor.style.fontSize =  `${paint_size.value * 10}px`;
				}
			}

			paint_color.onchange = function () {
				if (image_mode.value === 'font') {
					editor.style.color = paint_color.value;
				}
			}

			font.onchange = function () {
				if (image_mode.value === 'font') {
					editor.style.fontFamily = font.value;
				}
			}

			canvas.onmousedown = function(e) {
				let ele = get_position(canvas, e.clientX, e.clientY)
				let { x, y } = ele

				switch (image_mode.value) {
					case 'paint':
						is_allow_drawing = true;
						ctx.beginPath();
						ctx.moveTo(x, y);
						break;
					case 'font':
						editor.style.display='block';
						editor.style.left = `${e.clientX}px`;
						editor.style.top = `${e.clientY}px`;
						editor.style.fontSize = `${paint_size.value * 10}px`;
						editor.style.color = paint_color.value;
						editor.style.fontFamily = font.value;
						editor.style.fontWeight = 'bold';

						break
					default:
						break;
				}
			};

			canvas.onmousemove = (e) => {
				let ele = get_position(canvas, e.clientX, e.clientY)
				let { x, y } = ele;
				switch (image_mode.value) {
					case 'paint':
						if (is_allow_drawing) {
							ctx.lineWidth = paint_size.value;
							ctx.strokeStyle=paint_color.value;
							ctx.lineTo(x, y);
							ctx.stroke();
						}
						break;
					case 'font':
						break;

					default:
						break;
				}
			}

			canvas.onmouseup = function() {
				switch (image_mode.value) {
					case 'paint':
						is_allow_drawing = false;
						break;

					case 'font':
						editor.focus();
						is_allow_move_editor = false;
						break;

					default:
						break;
				}
			}

			canvas.onmouseleave = function () {
				if (image_mode.value === 'paint') {
					is_allow_drawing = false;
				}
			}
		}
	</script>
 <script>
        document.addEventListener('DOMContentLoaded', function() {
            const textInput = document.getElementById('textInput');
            const fontFamily = document.getElementById('fontFamily');
            const invertColors = document.getElementById('invertColors');
            const showGrid = document.getElementById('showGrid');
            const generateBtn = document.getElementById('generateBtn');
            const previewCanvas = document.getElementById('previewCanvas');
            const codeOutput = document.getElementById('codeOutput');
            const copyBtn = document.getElementById('copyBtn');
            const gridInfoText = document.getElementById('gridInfoText');
            const fontSizeSlider = document.getElementById('fontSizeSlider');
            const fontSizeValue = document.getElementById('fontSizeValue');

           // const datePicker = document.getElementById('datePicker');

          const gridSizeSelect = document.getElementById('gridSizeSelect');
            const currentGridSize = document.getElementById('currentGridSize');
            const sizeHint = document.getElementById('sizeHint');

            const ctx = previewCanvas.getContext('2d');
           // const gridSize = 16; // å•ä¸ªå­—ç¬¦çš„ç‚¹é˜µå°ºå¯¸ï¼ˆ16Ã—16ï¼‰
            const previewScale = 8; // é¢„è§ˆç¼©æ”¾æ¯”ä¾‹ï¼ˆ1ç‚¹é˜µ=10åƒç´ ï¼‰
            let fontSizeRatio = 0.85; // å­—ä½“å¤§å°æ¯”ä¾‹ï¼Œé»˜è®¤85%
            
            // åˆå§‹åŒ–é¢„è§ˆ
            updateGridSize();
            drawPreview();
             
            // ç”Ÿæˆå­—æ¨¡
            generateBtn.addEventListener('click', function() {
                drawPreview();
                generateCode();
            });
            
            // å¤åˆ¶ä»£ç 
            copyBtn.addEventListener('click', function() {
                sendcode();
            });
            
            // å­—ä½“å¤§å°è°ƒèŠ‚
            fontSizeSlider.addEventListener('input', function() {
                const value = this.value;
                fontSizeValue.textContent = `${value}%`;
                fontSizeRatio = value / 100;
                drawPreview();
            });
            
            // ç‚¹é˜µå°ºå¯¸åˆ‡æ¢
            gridSizeSelect.addEventListener('change', function() {
                updateGridSize();
                drawPreview();
            });
            // è·å–å½“å‰é€‰æ‹©çš„ç‚¹é˜µå°ºå¯¸
            function getCurrentGridSize() {
                return parseInt(gridSizeSelect.value);
            }
            
            // æ›´æ–°ç‚¹é˜µå°ºå¯¸ç›¸å…³æ˜¾ç¤º
            function updateGridSize() {
                const gridSize = getCurrentGridSize();
              
                currentGridSize.textContent = ``;
               //sizeHint.textContent = `è°ƒèŠ‚å­—ä½“åœ¨${gridSize}Ã—${gridSize}ç‚¹é˜µå†…çš„æ˜¾ç¤ºæ¯”ä¾‹ï¼Œè¿‡å¤§å¯èƒ½å¯¼è‡´å­—ç¬¦æˆªæ–­`;
            }
            
            
             // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
            function formatDate(date) {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                return `${year}å¹´${month}æœˆ${day}æ—¥`;
            }
            // ç»˜åˆ¶é¢„è§ˆï¼ˆé€‚é…åŠ¨æ€ç‚¹é˜µå°ºå¯¸ï¼‰
            function drawPreview() {
                const text = textInput.value || 'ABCDEFGH';
                const charCount = text.length;
                const font = fontFamily.value;
                const invert = invertColors.checked;
                const grid = showGrid.checked;
                const gridSize = getCurrentGridSize();
                
                // åŠ¨æ€è®¾ç½®ç”»å¸ƒå°ºå¯¸
                previewCanvas.width = charCount * gridSize * previewScale;
                previewCanvas.height = gridSize * previewScale;
                //gridInfoText.textContent = `${charCount}å­—ç¬¦ Ã— ${gridSize}Ã—${gridSize} ç‚¹é˜µï¼ˆæ€»å°ºå¯¸ï¼š${previewCanvas.width}Ã—${previewCanvas.height}åƒç´ ï¼‰`;
               
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                
                // ç»˜åˆ¶èƒŒæ™¯
                ctx.fillStyle = invert ? '#000000' : '#ffffff';
                ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
                
                // é€ä¸ªå­—ç¬¦ç»˜åˆ¶
                const charWidth = gridSize * previewScale;
                ctx.font = `bold ${gridSize * fontSizeRatio * previewScale}px ${font}`;
                ctx.textBaseline = 'middle';
                ctx.fillStyle = invert ? '#ffffff' : '#000000';
                
                for (let i = 0; i < charCount; i++) {
                    const currentChar = text[i];
                    const charX = i * charWidth + charWidth / 2;
                    ctx.textAlign = 'center';
                    ctx.fillText(currentChar, charX, previewCanvas.height / 2);
                }
                
                // ç»˜åˆ¶è‡ªé€‚åº”ç½‘æ ¼
                if (grid) {
                    ctx.strokeStyle = invert ? '#333333' : '#dddddd';
                    
                    // ç»˜åˆ¶å‚ç›´çº¿
                    for (let x = 0; x <= charCount * gridSize; x++) {
                        const lineX = x * previewScale;
                        ctx.beginPath();
                        ctx.moveTo(lineX, 0);
                        ctx.lineTo(lineX, previewCanvas.height);
                        ctx.lineWidth = x % gridSize === 0 ? 2 : 1;
                        ctx.stroke();
                    }
                    
                    // ç»˜åˆ¶æ°´å¹³çº¿
                    for (let y = 0; y <= gridSize; y++) {
                        const lineY = y * previewScale;
                        ctx.beginPath();
                        ctx.moveTo(0, lineY);
                        ctx.lineTo(previewCanvas.width, lineY);
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }
           // ç”Ÿæˆä»£ç ï¼ˆæŒ‰ç”»å¸ƒå–æ¨¡ï¼šæå–æ•´ä¸ªé¢„è§ˆç”»å¸ƒçš„ç‚¹é˜µæ•°æ®ï¼‰
// const charCount;
async  function sendcode(){

triggerRxTxCmd('FA');
	await delay(1000);
triggerRxTxCmd('E2');
}
async  function generateCode() {
            const text = textInput.value || 'ABCDEFGH';
                const charCount = text.length;
                const font = fontFamily.value;
                const invert = invertColors.checked;
                const gridSize = getCurrentGridSize();
                
                // æ€»ç‚¹é˜µå°ºå¯¸ï¼šå®½åº¦=å­—ç¬¦æ•°Ã—gridSizeï¼Œé«˜åº¦=gridSize
                const totalGridWidth = charCount * gridSize;
                const totalGridHeight = gridSize;
                
                // åˆ›å»ºä¸æ€»ç‚¹é˜µå°ºå¯¸ä¸€è‡´çš„ä¸´æ—¶ç”»å¸ƒ
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = totalGridWidth;
                tempCanvas.height = totalGridHeight;
                const tempCtx = tempCanvas.getContext('2d');
                
                // ç»˜åˆ¶å®Œæ•´ç”»å¸ƒå†…å®¹
                tempCtx.fillStyle = invert ? '#000000' : '#ffffff';
                tempCtx.fillRect(0, 0, totalGridWidth, totalGridHeight);
                tempCtx.font = `bold ${totalGridHeight * fontSizeRatio}px ${font}`;
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                tempCtx.fillStyle = invert ? '#ffffff' : '#000000';
                tempCtx.fillText(text, totalGridWidth / 2, totalGridHeight / 2);
                
                // è§£ææ•´ä¸ªç”»å¸ƒçš„åƒç´ æ•°æ®
                const imageData = tempCtx.getImageData(0, 0, totalGridWidth, totalGridHeight);
                const data = imageData.data;
                const allBytes = [];
                
                // æŒ‰è¡Œè§£æåƒç´ ï¼ˆæ ¹æ®ç‚¹é˜µå°ºå¯¸è‡ªåŠ¨è®¡ç®—æ¯è¡Œå­—èŠ‚æ•°ï¼‰
                for (let y = 0; y < totalGridHeight; y++) {
                    const bytesPerLine = totalGridWidth / 8; // æ¯è¡Œå­—èŠ‚æ•°=æ€»å®½åº¦/8
                    const lineBytes = new Array(bytesPerLine).fill(0);
                    
                    for (let x = 0; x < totalGridWidth; x++) {
                        const pixelIndex = (y * totalGridWidth + x) * 4;
                        const brightness = (data[pixelIndex] + data[pixelIndex + 1] + data[pixelIndex + 2]) / 3;
                        const bitValue = invert ? (brightness > 128 ? 0 : 1) : (brightness > 128 ? 1 : 0);
                        
                        const byteIndex = Math.floor(x / 8); // è®¡ç®—å½“å‰ç‚¹å±äºç¬¬å‡ ä¸ªå­—èŠ‚
                        const bitPosition = 7 - (x % 8); // è®¡ç®—å­—èŠ‚å†…çš„ä½ä½ç½®
                        lineBytes[byteIndex] |= (bitValue << bitPosition);
                    }
                    allBytes.push(...lineBytes);
                }
                

		
                if(gridSize==16){

                if(charCount>4){


                  let code='0'+4;
                  // æ ¼å¼åŒ–å­—èŠ‚æ˜¾ç¤ºï¼ˆæ¯2ä¸ªå­—èŠ‚ä¸€ç»„ï¼Œæ¯4ç»„æ¢è¡Œï¼Œä¸åŸä»£ç æ ¼å¼ä¸€è‡´ï¼‰
                  for (let i = 0; i < allBytes.length-1-(charCount-4)*32; i++) {
                      // è¡¥é›¶ä¸º2ä½åå…­è¿›åˆ¶ï¼ˆå¦‚1â†’01ï¼Œ15â†’0fï¼‰
                      code += `${allBytes[i].toString(16).padStart(2, '0')}`;

                  }
                
                triggerRxTxCmd(code);
                await delay(1000);

                  

                let code1='0'+charCount;
                  
                    for (let i = 128; i < allBytes.length-1; i++) {
                    // è¡¥é›¶ä¸º2ä½åå…­è¿›åˆ¶ï¼ˆå¦‚1â†’01ï¼Œ15â†’0fï¼‰
                    code1 += `${allBytes[i].toString(16).padStart(2, '0')}`;
                    
                    }
                  triggerRxTxCmd(code1);
                }else{

                      let code='0'+(charCount);
                  // æ ¼å¼åŒ–å­—èŠ‚æ˜¾ç¤ºï¼ˆæ¯2ä¸ªå­—èŠ‚ä¸€ç»„ï¼Œæ¯4ç»„æ¢è¡Œï¼Œä¸åŸä»£ç æ ¼å¼ä¸€è‡´ï¼‰
                  for (let i = 0; i < allBytes.length-1; i++) {
                      // è¡¥é›¶ä¸º2ä½åå…­è¿›åˆ¶ï¼ˆå¦‚1â†’01ï¼Œ15â†’0fï¼‰
                      code += `${allBytes[i].toString(16).padStart(2, '0')}`;
                      
                  }
                triggerRxTxCmd(code);
                
                }
      }else if(gridSize==24) 
      {

        if(charCount>4) return;

          for(let j=0;j<charCount;j++){
            let code='990'+j;

            // æ ¼å¼åŒ–å­—èŠ‚æ˜¾ç¤ºï¼ˆæ¯2ä¸ªå­—èŠ‚ä¸€ç»„ï¼Œæ¯4ç»„æ¢è¡Œï¼Œä¸åŸä»£ç æ ¼å¼ä¸€è‡´ï¼‰
                  for (let i = 0; i <72; i++) {
                      // è¡¥é›¶ä¸º2ä½åå…­è¿›åˆ¶ï¼ˆå¦‚1â†’01ï¼Œ15â†’0fï¼‰
                      code += `${allBytes[i+j*72].toString(16).padStart(2, '0')}`;

                  }
                
                triggerRxTxCmd(code);
              
                await delay(1000);


          }
          
                
                
                }

			// ç›‘å¬æ—¥æœŸé€‰æ‹©å˜åŒ–
          
                // è®¾ç½®æ—¥æœŸé€‰æ‹©å™¨é»˜è®¤å€¼ä¸ºä»Šå¤©
            // const today = new Date();
            // datePicker.valueAsDate = today;
            // selectedDateDisplay.textContent = formatDate(today);
       		 	const selectedDate = new Date(datePicker.value);
                //selectedDateDisplay.textContent = formatDate(selectedDate);
				        let year = selectedDate.getFullYear();
                let month = selectedDate.getMonth() + 1;
                let day =selectedDate.getDate();
				await delay(1000);
				
		
					if(month<10) month='0'+month;
					if(day<10) day='0'+day;
           if(gridSize==24) {
            let code2='ffff'+year+month+day;
                if(year>2000) {
                  triggerRxTxCmd(code2);};

           }else{
            let code2='ff00'+year+month+day;
            	if(year>2000) {
					triggerRxTxCmd(code2);};

          }
			//  let code2='ffff'+year+month+day;
      //           if(year>2000) {
      //             triggerRxTxCmd(code2);}
			

			await delay(1000);
				triggerRxTxCmd('E2');
}
            
            // ç›‘å¬è¾“å…¥å˜åŒ–ï¼Œå®æ—¶æ›´æ–°é¢„è§ˆ
            textInput.addEventListener('input', drawPreview);
            fontFamily.addEventListener('change', drawPreview);
            invertColors.addEventListener('change', drawPreview);
            showGrid.addEventListener('change', drawPreview);
        });
    </script>

	 <h2>å¢¨æ°´å±ä»·ç­¾è“ç‰™æ§åˆ¶å™¨
	 <!-- <a href="ATC_TLSR_Paper BLE control.html">è“ç‰™OTAå‡çº§</a> -->
	</h2>
<!-- åœ¨è¿æ¥æŒ‰é’®éƒ¨åˆ† -->
<div class="button-group">
  <button id="connectbutton" type="button" onclick="preConnect();">é“¾æ¥</button>
  <button type="button" onclick="reConnect();">é‡æ–°é“¾æ¥</button>
  <button type="button" onclick="document.getElementById('log').innerHTML = '';">æ¸…ç©ºæ—¥å¿—</button>
</div>

<!-- åœ¨æŒ‡ä»¤æ§åˆ¶éƒ¨åˆ† -->
<div class="button-group">
 <button id="time-setter" onclick="setTime()">è®¾ç½®æ—¶é—´ä¸º: </button>	<br>
	<input type="number" max="24" min="0" id="hour-offset" value="0" style="width: 40px;" >
  <!-- <h3>æŒ‡ä»¤æ§åˆ¶è®¾ç½®æ—¶é—´</h3>
	<button id="time-setter" onclick="setTime()">è®¾ç½®æ—¶é—´ä¸º: </button>	<br>
	åç§»+<input type="number" max="24" min="0" id="hour-offset" value="0" style="width: 40px;">å°æ—¶ -->
  <!-- <input type="text" id="cmdTXT" placeholder="è¾“å…¥å‘½ä»¤" value="0155">
	<button onclick="triggerEpdCmd(document.getElementById('cmdTXT').value)">å‘é€å‘½ä»¤</button> -->
 
</div>

<div class="button-group">
  <button type="button" onclick="triggerRxTxCmd('e100')" title="ç‚¹å‡»è¯¥æŒ‰é’®ï¼Œç„¶åä¸Šä¼ å›¾ç‰‡ã€‚å›¾ç‰‡å°†æ°¸ä¹…æ˜¾ç¤ºåˆ°å±å¹•ä¸Š">è®¾ç½®ä¸ºå›¾ç‰‡æ¨¡å¼</button>
  <button type="button" onclick="setri('e101')" title="ç‚¹å‡»è¯¥æŒ‰é’®, åˆ‡æ¢ä¸ºæ—¶é’Ÿæ¨¡å¼">åˆ‡æ¢æ—¥å†æ¨¡å¼</button>
  <button type="button" onclick="setri('e102')" title="ç‚¹å‡»è¯¥æŒ‰é’®, åˆ‡æ¢ä¸ºæ—¶é’Ÿæ¨¡å¼">åˆ‡æ¢æ—¶é’Ÿæ¨¡å¼</button>
  
</div>

<div class="button-group">
  <button type="button" onclick="triggerRxTxCmd('e3')" title="ç‚¹å‡»è¯¥æŒ‰é’®ï¼Œè®¾ç½®ä¸ºåè‰²æ¨¡å¼">åˆ‡æ¢åè‰²æ¨¡å¼</button>
  <button type="button" onclick="triggerRxTxCmd('e5')" title="ç‚¹å‡»è¯¥æŒ‰é’®ï¼Œè®¾ç½®ä¸ºç¿»è½¬æ¨¡å¼">åˆ‡æ¢ä¸ºç¿»è½¬æ¨¡å¼</button>
  <input type="text" id="cmdlut_red" placeholder="16è¿›åˆ¶è¾“å…¥00åˆ°0fã€‚é»˜è®¤ä¸º0aï¼Œè€åŒ–å±å»ºè®®0c" value="">
	<button onclick="triggerEpdRed_lut(document.getElementById('cmdlut_red').value)">æ ¡å‡†çº¢è‰²å±€åˆ·</button>
  <button type="button" onclick="triggerRxTxCmd('E2')" title="ç‚¹å‡»è¯¥æŒ‰é’®, åˆ‡æ¢ä¸ºæ—¶é’Ÿæ¨¡å¼">(æ²¡ååº”å°±ç‚¹ä¸‹)åˆ·æ–°</button>
</div>
	<br><br>
	 <section class="date-picker-section">
            <h2>å€’è®¡æ—¶æ—¥æœŸé€‰æ‹©å™¨ï¼Œé€‰æ‹©æ‰ç”Ÿæ•ˆ</h2>
            <div class="date-picker-container">
                <label for="datePicker">é€‰æ‹©ä¸€ä¸ªæ—¥æœŸ:</label>
                <input type="date" id="datePicker">
                
            </div>
        </section>

<div class="main-content">
            <div class="input-section">
                <div class="section-title">
                    <i>ğŸ“</i> è¾“å…¥è®¾ç½®
                </div>
                
                <div class="input-group">
                    <label for="textInput">è¾“å…¥æ–‡å­— (æ—¶é’Ÿè®¡æ—¶8ä¸ªå­—ç¬¦ä»¥å†…ï¼Œæ—¥å†è®¡æ—¶4ä¸ªå­—ç¬¦ä»¥å†…)</label>
                    <input type="text" id="textInput" maxlength="8" value="è·ç¦»æˆä¸ºé¦–å¯Œè¿˜æœ‰" placeholder="è¯·è¾“å…¥1-8ä¸ªå­—ç¬¦">
                </div>
                <div class="input-group">
                    <label for="gridSizeSelect">å€’è®¡æ—¶ç•Œé¢é€‰æ‹©</label>
                    <select id="gridSizeSelect">
                      
                        <option value="24">æ—¥å†è®¡æ—¶ç•Œé¢</option>
                        <option value="16">æ—¶é’Ÿè®¡æ—¶ç•Œé¢</option>
                    </select>
                     <div><span id="currentGridSize"></span></div>
                </div>
                <div class="input-group" >
                    <label for="fontFamily">å­—ä½“é€‰æ‹©ï¼ˆç”µè„‘ç«¯ç”Ÿæ•ˆï¼‰</label>
                    <select id="fontFamily">
                        <option value="Arial">Arial</option>
                        <option value="SimSun" selected="">å®‹ä½“</option>
                        <option value="Microsoft YaHei">å¾®è½¯é›…é»‘</option>
                        <option value="SimHei">é»‘ä½“</option>
                        <option value="KaiTi">æ¥·ä½“</option>
                    </select>
                </div>
                
                <div class="input-group" >
                    <label for="fontSizeSlider">å­—ä½“å¤§å° (50%-150%)</label>
                    <div class="slider-container">
                        <input type="range" id="fontSizeSlider" min="50" max="150" value="100">
                        <span class="slider-value" id="fontSizeValue">100%</span>
                    </div>
                    <small style="color: #7f8c8d;">è°ƒèŠ‚å­—ä½“çš„æ˜¾ç¤ºæ¯”ä¾‹ï¼Œè¿‡å¤§å¯èƒ½å¯¼è‡´å­—ç¬¦æˆªæ–­</small>
                </div>
                
                <div class="options"  style="display:none">
                    <div class="option-item">
                        <input type="checkbox" id="invertColors" checked="">
                        <label for="invertColors">åè‰²æ˜¾ç¤º</label>
                    </div>
                    <div class="option-item" style="display:none">
                        <input type="checkbox" id="showGrid" checked="">
                        <label for="showGrid">æ˜¾ç¤ºç½‘æ ¼</label>
                    </div>
                </div>
                
               
            </div>
            
            <div class="preview-section"  >
                <div class="section-title">
                    <i>ğŸ‘ï¸</i> 
                </div>
                
                <div class="preview-container">
                    <canvas id="previewCanvas" width="30" height="30" ></canvas>
                	 <div class="grid-info" id="gridInfoText" ></div>
                </div>
                
                <!-- <div class="section-title" style="margin-top: 20px;"width="10px" >
                    <i>ğŸ’»</i> å¤šå­—ç¬¦ç»„åˆå­—æ¨¡ä»£ç 
                </div>
                
                <div class="code-container" id="codeOutput" >// å­—ç¬¦ç»„åˆ: ABCD (SimSun) - é¡ºåºï¼šA â†’ B â†’ C â†’ D</div> -->
                
                
            </div>
            
             <button id="generateBtn">å¯åŠ¨å€’è®¡æ—¶æ—¥æœŸ</button>
             
				<button class="copy-btn" id="copyBtn">å…³é—­å€’è®¡æ—¶æ—¥æœŸ</button>
        </div>
    </div>


</div>
	

	
	<br><br>

<h3>ä¸Šä¼ å›¾ç‰‡åˆ°å±å¹•</h3>
   å±å¹•å°ºå¯¸ï¼š
	<select id="screen-size" onchange="updateCanvasSize()">
		<option value="4.2ä¼ å›¾">å…¨å±ä¼ å›¾</option>
    
		<option value="æ—¥å†å°å›¾">æ—¥å†å°å›¾</option>
    <option value="7.5ä¼ å›¾">2.9ä¼ å›¾</option> -->
    <option value="2.9ä¼ å›¾">2.9ä¼ å›¾</option> -->
      <option value="2.13ä¼ å›¾">2.9ä¼ å›¾</option>
	</select>
	<input type="file" id="image_file" onchange="update_image()" accept=".png,.jpg,.bmp,.webp,.jpeg">
	æŠ–åŠ¨ç®—æ³•ï¼š
	<select id="dithering" title="æŠ–åŠ¨ç®—æ³•">
	
		<optgroup label="é»‘ç™½çº¢å¤šè‰²">
			<option value="bwr_floydsteinberg">é»‘ç™½çº¢floydsteinberg</option>
			<option value="bwr_Atkinson">é»‘ç™½çº¢Atkinson</option>
		</optgroup>
	</select>
	é˜ˆå€¼:
	<input type="number" max="255" min="0" value="125" id="threshold">
	<button onclick="update_image()">é‡æ–°åŠ è½½</button>
	<br>

	<!-- <div id="canvas-box">
		<div id="tool-box">
			æ¨¡å¼ï¼š
			<select id="canvas-mode">
				<option value="paint">ç”»ç¬”</option>
				<option value="font" title="è¾“å…¥å®Œæˆå ç‚¹å‡»ï¼šä¿å­˜æ–‡æœ¬æ¡†">è¾“å…¥æ–‡å­—</option>
			</select>
			ç”»ç¬”/æ–‡å­—å¤§å°ï¼š
			<input type="number" max="13" min="1" step="1" value="3" id="paint-size">
			ç”»ç¬”é¢œè‰²ï¼š
			<select id="paint-color">
				<option value="red">çº¢è‰²</option>
				<option value="white">ç™½è‰²</option>
				<option value="black">é»‘è‰²</option>
			</select>

			<select id="font" title="å­—ä½“" style="display: none;">
				<option value="å¾®è½¯é›…é»‘">å¾®è½¯é›…é»‘</option>
				<option value="é»‘ä½“">é»‘ä½“</option>
				<option value="ä»¿å®‹">ä»¿å®‹</option>
				<option value="å®‹ä½“">å®‹ä½“</option>
				<option value="æ¥·ä½“_GB2312">æ¥·ä½“_GB2312</option>
				<option value="åæ–‡è¡Œæ¥·">åæ–‡è¡Œæ¥·</option>
			</select>
			<button id="update-text" style="display: none">ä¿å­˜æ–‡æœ¬æ¡†</button>
			<button onclick="clear_canvas()">æ¸…å±</button>
		</div> -->
		<input id="edit-font" style="max-width: 300px; position: absolute; border: black solid 1px;background-color: rgba(0,0,0,0);display: none;overflow: auto" />
	<!-- <canvas id="canvas" width="300" height="400" style="border: black solid 1px;"></canvas> -->
 
  <canvas id="canvas" style="border: black solid 1px;"></canvas>
		<br>
		<button onclick="upload_image()" style="font-weight: bold">ç«‹å³ä¸Šä¼ åˆ°å±å¹•</button>
		<br>
	</div>


  

	<div id="log-box" >
		æ—¥å¿—ï¼š
		<br>
		<div id="log" >
 
		</div>
	</div>

  æ¿€æ´»<input type="text" id="cmdJH" placeholder="è¾“å…¥æ¿€æ´»ç " value="">
			<button onclick="triggerEpdJH(document.getElementById('cmdJH').value)">å¼€å§‹æ¿€æ´»</button>
</body>

</html>
